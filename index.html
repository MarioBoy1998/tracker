<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>Table Tracker</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<style>
html,body{margin:0;height:100%;background:#0e0e0e;color:#fff;font-family:Arial;overflow:hidden}

#status{position:fixed;top:10px;right:10px;padding:8px 16px;border-radius:20px;font-size:12px;font-weight:bold;z-index:1000}
#status.connected{background:#22c55e;color:#000}
#status.disconnected{background:#ef4444;color:#fff}
#status.connecting{background:#f59e0b;color:#000}

#header{text-align:center;padding:20px;background:#1a1a1a;border-bottom:2px solid #333}
#header h1{margin:0;font-size:32px;font-weight:700;color:#ef4444}

#stats{display:flex;justify-content:center;gap:40px;padding:15px;background:#1a1a1a;border-bottom:1px solid #333}
.stat{text-align:center}
.stat-value{font-size:28px;font-weight:700;color:#ef4444}
.stat-label{font-size:11px;opacity:0.7;margin-top:4px;text-transform:uppercase;letter-spacing:1px}

#rooms{display:flex;flex-direction:column;height:calc(100vh - 160px);overflow-y:auto}
.room{flex:1;border-bottom:2px solid #333;padding:20px;display:flex;flex-direction:column;min-height:0}
.room:last-child{border-bottom:0}
.room.offline{background:#1a0000}

.room-header{text-align:center;margin-bottom:16px}
.room-header h2{margin:0;font-size:28px;font-weight:700;color:#ef4444}
.room-status{font-size:14px;opacity:0.7;margin-top:4px}
.room-status.offline{color:#ef4444}
.room-status.online{color:#22c55e}

.tables{display:flex;gap:16px;flex-wrap:wrap;justify-content:center;align-items:center;align-content:center;overflow-y:auto;flex:1}

.table{border-radius:50%;display:flex;align-items:center;justify-content:center;flex-direction:column;font-weight:700;position:relative;box-shadow:0 4px 12px rgba(0,0,0,0.3);transition:all 0.3s ease;cursor:pointer}

.table.active{background:#22c55e}
.table.warning{background:#f59e0b;animation:pulse-warning 2s infinite}
.table.inactive{background:#ef4444;animation:pulse-inactive 2s infinite}
.table.stale{background:#666;opacity:0.6}

.table:hover{transform:scale(1.1)}

.table .id{font-size:1em}
.table .rssi{font-size:0.5em;font-weight:400;margin-top:0.2em;opacity:0.8}
.table .time{font-size:0.4em;font-weight:400;margin-top:0.1em;opacity:0.7}

.empty{opacity:.4;text-align:center;padding:40px;width:100%;font-size:20px}

@keyframes pulse-warning{0%,100%{opacity:1}50%{opacity:0.7}}
@keyframes pulse-inactive{0%,100%{opacity:1}50%{opacity:0.6}}

#legend{background:#1a1a1a;padding:10px;text-align:center;font-size:11px;border-bottom:1px solid #333}
.legend-item{display:inline-block;margin:0 15px}
.legend-dot{display:inline-block;width:10px;height:10px;border-radius:50%;margin-right:5px;vertical-align:middle}
</style>
</head>
<body>

<div id="status" class="connecting">Connecting...</div>

<div id="header">
  <h1>‚ö° TABLE TRACKER</h1>
</div>

<div id="stats">
  <div class="stat">
    <div class="stat-value" id="stat-rooms">0</div>
    <div class="stat-label">Rooms</div>
  </div>
  <div class="stat">
    <div class="stat-value" id="stat-tables">0</div>
    <div class="stat-label">Tables</div>
  </div>
  <div class="stat">
    <div class="stat-value" id="stat-active">0</div>
    <div class="stat-label">Active</div>
  </div>
  <div class="stat">
    <div class="stat-value" id="stat-masters">0</div>
    <div class="stat-label">Masters</div>
  </div>
</div>

<div id="legend">
  <span class="legend-item"><span class="legend-dot" style="background:#22c55e"></span>Active (&lt;30s)</span>
  <span class="legend-item"><span class="legend-dot" style="background:#f59e0b"></span>Warning (30s-15m)</span>
  <span class="legend-item"><span class="legend-dot" style="background:#ef4444"></span>Inactive (15m-30m)</span>
  <span class="legend-item"><span class="legend-dot" style="background:#666"></span>Stale (&gt;30m)</span>
</div>

<div id="rooms"></div>

<script src="https://unpkg.com/mqtt@5.3.4/dist/mqtt.min.js"></script>
<script>
// ================= CONFIG =================
const MQTT_HOST = 'wss://f3fbfed182654a99bd2d329ffb0aef99.s1.eu.hivemq.cloud:8884/mqtt';
const MQTT_USERNAME = 'master1';
const MQTT_PASSWORD = 'Qwerty1234!';

const MASTER_TIMEOUT = 15000;
const TABLE_WARNING_TIMEOUT = 30000;
const TABLE_INACTIVE_TIMEOUT = 900000;
const TABLE_STALE_TIMEOUT = 1800000;
const CLEANUP_INTERVAL = 3600000;

const SIGNAL_FRESHNESS_THRESHOLD = 30000;
const RSSI_DIFFERENCE_THRESHOLD = 10;
const MIN_RSSI_FOR_ROOM = -90;

// ================= DATA =================
let masters = {};
let tables = {};

// ================= MQTT =================
const client = mqtt.connect(MQTT_HOST, {
  username: MQTT_USERNAME,
  password: MQTT_PASSWORD,
  clean: true,
  connectTimeout: 4000,
  reconnectPeriod: 1000,
});

client.on('connect', () => {
  console.log('‚úÖ Connected');
  document.getElementById('status').className = 'connected';
  document.getElementById('status').textContent = 'Connected';
  
  client.subscribe('tracker/raw/#', (err) => {
    if (!err) console.log('üì° Subscribed');
  });
});

client.on('message', (topic, message) => {
  try {
    if (topic.startsWith('tracker/raw/')) {
      const masterId = topic.split('/')[2];
      const data = JSON.parse(message.toString());
      handleMasterData(masterId, data);
    }
  } catch (e) {
    console.error('Parse error:', e);
  }
});

client.on('disconnect', () => {
  document.getElementById('status').className = 'disconnected';
  document.getElementById('status').textContent = 'Disconnected';
});

client.on('error', (error) => {
  document.getElementById('status').className = 'disconnected';
  document.getElementById('status').textContent = 'Error';
});

client.on('reconnect', () => {
  document.getElementById('status').className = 'connecting';
  document.getElementById('status').textContent = 'Reconnecting...';
});

// ================= HANDLERS =================
function handleMasterData(masterId, data) {
  const now = Date.now();
  
  masters[masterId] = {
    room: data.room,
    master_id: data.master_id,
    lastSeen: now,
    active: true
  };
  
  console.log(`üì® Master ${masterId} (${data.room}): ${data.tables.length} tables`);
  
  (data.tables || []).forEach(table => {
    const tableId = table.id;
    const rssi = table.rssi;
    const lastSeen = table.last_seen || 0;
    
    if (!tables[tableId]) {
      tables[tableId] = { signals: [] };
      console.log(`  [+] TX_${tableId}`);
    }
    
    const existingIndex = tables[tableId].signals.findIndex(
      s => s.master_id === data.master_id
    );
    
    const signal = {
      room: data.room,
      master_id: data.master_id,
      rssi: rssi,
      timestamp: now - lastSeen
    };
    
    if (existingIndex >= 0) {
      tables[tableId].signals[existingIndex] = signal;
    } else {
      tables[tableId].signals.push(signal);
    }
  });
  
  processAndRender();
}

// ================= PROCESS =================
function processAndRender() {
  const now = Date.now();
  
  // Timeout Masters
  for (let masterId in masters) {
    if (now - masters[masterId].lastSeen > MASTER_TIMEOUT) {
      if (masters[masterId].active) {
        console.log(`‚ö†Ô∏è Master ${masterId} timeout`);
        masters[masterId].active = false;
      }
    }
  }
  
  // Cleanup old signals
  for (let tableId in tables) {
    tables[tableId].signals = tables[tableId].signals.filter(signal => {
      return (now - signal.timestamp) < CLEANUP_INTERVAL;
    });
    
    if (tables[tableId].signals.length === 0) {
      console.log(`  [-] TX_${tableId}`);
      delete tables[tableId];
    }
  }
  
  // Build rooms
  let rooms = {};
  
  for (let masterId in masters) {
    if (!masters[masterId].active) continue;
    
    const room = masters[masterId].room;
    if (!rooms[room]) {
      rooms[room] = {
        active: true,
        master_id: masters[masterId].master_id,
        tables: {}
      };
    }
  }
  
  // Process tables
  let activeCount = 0;
  let warningCount = 0;
  let inactiveCount = 0;
  let staleCount = 0;
  
  for (let tableId in tables) {
    const signals = tables[tableId].signals;
    if (signals.length === 0) continue;
    
    const lastSignal = signals.reduce((newest, current) => {
      return current.timestamp > newest.timestamp ? current : newest;
    });
    const currentRoom = lastSignal.room;
    
    const signalsByRoom = {};
    signals.forEach(signal => {
      if (!signalsByRoom[signal.room]) signalsByRoom[signal.room] = [];
      signalsByRoom[signal.room].push(signal);
    });
    
    const freshestByRoom = {};
    for (let room in signalsByRoom) {
      freshestByRoom[room] = signalsByRoom[room].reduce((newest, current) => {
        return current.timestamp > newest.timestamp ? current : newest;
      });
    }
    
    const currentRoomSignal = freshestByRoom[currentRoom];
    const currentRoomAge = currentRoomSignal ? (now - currentRoomSignal.timestamp) : Infinity;
    const currentRoomFresh = currentRoomAge < SIGNAL_FRESHNESS_THRESHOLD;
    
    let finalRoom = currentRoom;
    let finalSignal = currentRoomSignal || lastSignal;
    let moveReason = 'staying';
    
    if (currentRoomFresh && currentRoomSignal.rssi >= MIN_RSSI_FOR_ROOM) {
      let bestRoom = currentRoom;
      let bestSignal = currentRoomSignal;
      
      for (let room in freshestByRoom) {
        if (room === currentRoom) continue;
        
        const signal = freshestByRoom[room];
        const age = now - signal.timestamp;
        const isFresh = age < SIGNAL_FRESHNESS_THRESHOLD;
        
        if (isFresh && signal.rssi >= MIN_RSSI_FOR_ROOM) {
          if (signal.rssi - bestSignal.rssi > RSSI_DIFFERENCE_THRESHOLD) {
            bestRoom = room;
            bestSignal = signal;
            moveReason = `moved (${bestSignal.rssi} vs ${currentRoomSignal.rssi})`;
          }
        }
      }
      
      finalRoom = bestRoom;
      finalSignal = bestSignal;
      
    } else if (currentRoomFresh && currentRoomSignal.rssi < MIN_RSSI_FOR_ROOM) {
      let bestRoom = null;
      let bestSignal = null;
      
      for (let room in freshestByRoom) {
        const signal = freshestByRoom[room];
        const age = now - signal.timestamp;
        const isFresh = age < SIGNAL_FRESHNESS_THRESHOLD;
        
        if (isFresh && signal.rssi >= MIN_RSSI_FOR_ROOM) {
          if (!bestSignal || signal.rssi > bestSignal.rssi) {
            bestRoom = room;
            bestSignal = signal;
          }
        }
      }
      
      if (bestSignal) {
        finalRoom = bestRoom;
        finalSignal = bestSignal;
        moveReason = `moved (weak: ${currentRoomSignal.rssi}, new: ${bestSignal.rssi})`;
      } else {
        moveReason = 'staying (all weak)';
      }
      
    } else {
      let emergencyRoom = null;
      let emergencySignal = null;
      
      for (let room in freshestByRoom) {
        const signal = freshestByRoom[room];
        const age = now - signal.timestamp;
        
        if (age < 10000 && signal.rssi >= MIN_RSSI_FOR_ROOM) {
          if (signal.rssi - finalSignal.rssi > RSSI_DIFFERENCE_THRESHOLD * 2) {
            emergencyRoom = room;
            emergencySignal = signal;
            break;
          }
        }
      }
      
      if (emergencySignal) {
        finalRoom = emergencyRoom;
        finalSignal = emergencySignal;
        moveReason = `emergency (${emergencySignal.rssi})`;
      } else {
        moveReason = `waiting (${currentRoom})`;
      }
    }
    
    const lastSeen = now - finalSignal.timestamp;
    
    let status = 'active';
    if (lastSeen > TABLE_STALE_TIMEOUT) {
      status = 'stale';
      staleCount++;
    } else if (lastSeen > TABLE_INACTIVE_TIMEOUT) {
      status = 'inactive';
      inactiveCount++;
    } else if (lastSeen > TABLE_WARNING_TIMEOUT) {
      status = 'warning';
      warningCount++;
    } else {
      activeCount++;
    }
    
    if (finalRoom !== currentRoom) {
      console.log(`  TX_${tableId}: ${currentRoom} ‚Üí ${finalRoom} (${moveReason})`);
    }
    
    if (rooms[finalRoom]) {
      rooms[finalRoom].tables[tableId] = {
        rssi: finalSignal.rssi,
        last_seen: lastSeen,
        status: status
      };
    }
  }
  
  const roomCount = Object.keys(rooms).length;
  const tableCount = Object.keys(tables).length;
  const masterCount = Object.keys(masters).filter(id => masters[id].active).length;
  
  console.log(`üìä ${roomCount} rooms, ${tableCount} tables (‚úì${activeCount} ‚ö†${warningCount} ‚úó${inactiveCount} ‚è∏${staleCount})`);
  
  render(rooms, roomCount, tableCount, activeCount, masterCount);
}

// ================= RENDER =================
function calcSize(count) {
  if (count === 0) return 80;
  if (count <= 5) return 120;
  if (count <= 10) return 100;
  if (count <= 20) return 80;
  if (count <= 40) return 60;
  return 50;
}

function render(rooms, roomCount, tableCount, activeCount, masterCount) {
  if (!rooms || Object.keys(rooms).length === 0) {
    document.getElementById('rooms').innerHTML = '<div class="empty">Waiting for data...</div>';
    updateStats(0, 0, 0, 0);
    return;
  }
  
  let html = '';
  let roomNames = Object.keys(rooms).sort();
  
  roomNames.forEach(roomName => {
    let room = rooms[roomName];
    let tables = room.tables || {};
    let tableIds = Object.keys(tables);
    let count = tableIds.length;
    let size = calcSize(count);
    let isActive = room.active !== false;
    
    html += `<div class="room ${isActive ? '' : 'offline'}">
      <div class="room-header">
        <h2>${roomName}</h2>
        <div class="room-status ${isActive ? 'online' : 'offline'}">${isActive ? 'Online' : 'Offline'}</div>
      </div>
      <div class="tables">`;
    
    if (count === 0) {
      html += '<div class="empty">No tables</div>';
    } else {
      tableIds.sort((a, b) => parseInt(a) - parseInt(b));
      
      tableIds.forEach(tableId => {
        let table = tables[tableId];
        let status = table.status || 'active';
        let rssi = table.rssi || 0;
        let lastSeen = table.last_seen || 0;
        let time = lastSeen < 1000 ? 'now' : 
                   lastSeen < 60000 ? `${Math.floor(lastSeen/1000)}s` :
                   lastSeen < 3600000 ? `${Math.floor(lastSeen/60000)}m` :
                   `${Math.floor(lastSeen/3600000)}h`;
        
        html += `<div class="table ${status}" 
                 style="width:${size}px;height:${size}px;font-size:${size/4}px"
                 title="TX_${tableId}: ${rssi} dBm, ${time}">
          <div class="id">${tableId}</div>
          <div class="rssi">${rssi} dBm</div>
          <div class="time">${time}</div>
        </div>`;
      });
    }
    
    html += '</div></div>';
  });
  
  document.getElementById('rooms').innerHTML = html;
  updateStats(roomCount, tableCount, activeCount, masterCount);
}

function updateStats(rooms, tables, active, masters) {
  document.getElementById('stat-rooms').textContent = rooms;
  document.getElementById('stat-tables').textContent = tables;
  document.getElementById('stat-active').textContent = active;
  document.getElementById('stat-masters').textContent = masters;
}

// Auto cleanup
setInterval(() => {
  const now = Date.now();
  for (let tableId in tables) {
    tables[tableId].signals = tables[tableId].signals.filter(signal => {
      return (now - signal.timestamp) < CLEANUP_INTERVAL;
    });
    if (tables[tableId].signals.length === 0) {
      delete tables[tableId];
    }
  }
  processAndRender();
}, 60000);

// Init
render({}, 0, 0, 0, 0);
</script>
</body>
</html>
