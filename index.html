<!DOCTYPE html>
<html lang="uk">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Table Tracker Dashboard</title>
<style>
* {
  box-sizing: border-box;
  margin: 0;
  padding: 0;
}

body {
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
  color: #fff;
  min-height: 100vh;
  overflow-x: hidden;
}

/* Header */
.header {
  background: rgba(0, 0, 0, 0.2);
  backdrop-filter: blur(10px);
  padding: 20px;
  display: flex;
  justify-content: space-between;
  align-items: center;
  flex-wrap: wrap;
  gap: 15px;
  box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
}

.header h1 {
  font-size: 28px;
  font-weight: 700;
  display: flex;
  align-items: center;
  gap: 10px;
}

/* Status Badge */
.status-badge {
  padding: 8px 20px;
  border-radius: 20px;
  font-size: 14px;
  font-weight: 600;
  display: inline-flex;
  align-items: center;
  gap: 8px;
  transition: all 0.3s;
}

.status-badge::before {
  content: '';
  width: 8px;
  height: 8px;
  border-radius: 50%;
  animation: pulse 2s infinite;
}

.status-badge.connected {
  background: #22c55e;
  color: #000;
}

.status-badge.connected::before {
  background: #000;
}

.status-badge.disconnected {
  background: #ef4444;
  color: #fff;
}

.status-badge.disconnected::before {
  background: #fff;
}

.status-badge.connecting {
  background: #f59e0b;
  color: #000;
}

.status-badge.connecting::before {
  background: #000;
}

@keyframes pulse {
  0%, 100% { opacity: 1; }
  50% { opacity: 0.5; }
}

/* Controls */
.controls {
  background: rgba(255, 255, 255, 0.15);
  backdrop-filter: blur(10px);
  border-radius: 15px;
  padding: 15px 20px;
  display: flex;
  align-items: center;
  gap: 15px;
  flex-wrap: wrap;
}

.controls label {
  font-size: 13px;
  opacity: 0.9;
  font-weight: 500;
}

.controls input {
  background: rgba(255, 255, 255, 0.2);
  border: 1px solid rgba(255, 255, 255, 0.3);
  color: #fff;
  padding: 8px 12px;
  border-radius: 8px;
  width: 90px;
  font-size: 14px;
  font-weight: 600;
}

.controls input::placeholder {
  color: rgba(255, 255, 255, 0.5);
}

.controls button {
  background: #fff;
  color: #667eea;
  border: none;
  padding: 8px 20px;
  border-radius: 8px;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.3s;
}

.controls button:hover {
  transform: translateY(-2px);
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
}

/* Stats Bar */
.stats {
  background: rgba(0, 0, 0, 0.2);
  backdrop-filter: blur(10px);
  padding: 15px 20px;
  display: flex;
  justify-content: center;
  gap: 40px;
  flex-wrap: wrap;
}

.stat {
  text-align: center;
}

.stat-value {
  font-size: 32px;
  font-weight: 700;
  line-height: 1;
}

.stat-label {
  font-size: 12px;
  opacity: 0.8;
  margin-top: 5px;
  text-transform: uppercase;
  letter-spacing: 1px;
}

/* Rooms Container */
.rooms-container {
  padding: 20px;
  display: flex;
  flex-direction: column;
  gap: 20px;
}

/* Room Card */
.room-card {
  background: rgba(255, 255, 255, 0.95);
  border-radius: 20px;
  overflow: hidden;
  box-shadow: 0 10px 40px rgba(0, 0, 0, 0.2);
  transition: all 0.3s;
}

.room-card:hover {
  transform: translateY(-5px);
  box-shadow: 0 15px 50px rgba(0, 0, 0, 0.3);
}

.room-card.offline {
  opacity: 0.6;
  background: rgba(239, 68, 68, 0.1);
}

.room-header {
  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
  padding: 20px;
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.room-title {
  color: #fff;
  font-size: 24px;
  font-weight: 700;
}

.room-status {
  background: rgba(255, 255, 255, 0.2);
  color: #fff;
  padding: 6px 16px;
  border-radius: 20px;
  font-size: 13px;
  font-weight: 600;
  display: flex;
  align-items: center;
  gap: 6px;
}

.room-status::before {
  content: '';
  width: 6px;
  height: 6px;
  border-radius: 50%;
  background: #fff;
}

.room-status.offline {
  background: rgba(239, 68, 68, 0.3);
}

.room-status.offline::before {
  background: #ef4444;
}

.room-body {
  padding: 30px;
  min-height: 200px;
}

.tables-grid {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
  gap: 20px;
  justify-items: center;
}

.table {
  width: 100px;
  height: 100px;
  border-radius: 50%;
  background: linear-gradient(135deg, #22c55e 0%, #16a34a 100%);
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  color: #fff;
  font-weight: 700;
  box-shadow: 0 4px 15px rgba(34, 197, 94, 0.3);
  transition: all 0.3s;
  cursor: pointer;
  position: relative;
}

.table:hover {
  transform: scale(1.1);
  box-shadow: 0 8px 25px rgba(34, 197, 94, 0.5);
}

.table.inactive {
  background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);
  box-shadow: 0 4px 15px rgba(239, 68, 68, 0.3);
  animation: pulse-red 2s infinite;
}

@keyframes pulse-red {
  0%, 100% { opacity: 1; }
  50% { opacity: 0.7; }
}

.table-id {
  font-size: 28px;
  font-weight: 700;
}

.table-rssi {
  font-size: 11px;
  opacity: 0.9;
  margin-top: 4px;
}

.empty-state {
  text-align: center;
  padding: 60px 20px;
  color: #94a3b8;
}

.empty-state-icon {
  font-size: 64px;
  opacity: 0.3;
  margin-bottom: 15px;
}

.empty-state-text {
  font-size: 18px;
  font-weight: 500;
}

/* Loading */
.loading {
  text-align: center;
  padding: 100px 20px;
  color: #fff;
  font-size: 20px;
}

.spinner {
  border: 4px solid rgba(255, 255, 255, 0.3);
  border-top: 4px solid #fff;
  border-radius: 50%;
  width: 50px;
  height: 50px;
  animation: spin 1s linear infinite;
  margin: 0 auto 20px;
}

@keyframes spin {
  0% { transform: rotate(0deg); }
  100% { transform: rotate(360deg); }
}

/* Responsive */
@media (max-width: 768px) {
  .header h1 {
    font-size: 20px;
  }
  
  .controls {
    width: 100%;
    justify-content: center;
  }
  
  .stats {
    gap: 20px;
  }
  
  .stat-value {
    font-size: 24px;
  }
  
  .tables-grid {
    grid-template-columns: repeat(auto-fill, minmax(80px, 1fr));
    gap: 15px;
  }
  
  .table {
    width: 80px;
    height: 80px;
  }
  
  .table-id {
    font-size: 22px;
  }
}
</style>
</head>
<body>

<div class="header">
  <h1>ðŸŽ¯ Table Tracker</h1>
  <div class="status-badge connecting" id="status">Connecting...</div>
</div>

<div class="controls">
  <label>ESP-NOW:</label>
  <input type="number" id="espnow-time" value="5000" min="1000" max="30000" step="1000">
  <label>ms</label>
  
  <label style="margin-left: 10px">Cycle:</label>
  <input type="number" id="cycle-interval" value="6000" min="2000" max="60000" step="1000">
  <label>ms</label>
  
  <button onclick="updateConfig()">Apply Config</button>
</div>

<div class="stats" id="stats">
  <div class="stat">
    <div class="stat-value" id="stat-rooms">0</div>
    <div class="stat-label">Rooms</div>
  </div>
  <div class="stat">
    <div class="stat-value" id="stat-tables">0</div>
    <div class="stat-label">Tables</div>
  </div>
  <div class="stat">
    <div class="stat-value" id="stat-active">0</div>
    <div class="stat-label">Active</div>
  </div>
</div>

<div class="rooms-container" id="rooms">
  <div class="loading">
    <div class="spinner"></div>
    Waiting for data from Masters...
  </div>
</div>

<script src="https://unpkg.com/mqtt@5.3.4/dist/mqtt.min.js"></script>
<script>
// ================= CONFIG =================
const MQTT_HOST = 'wss://f3fbfed182654a99bd2d329ffb0aef99.s1.eu.hivemq.cloud:8884/mqtt';
const MQTT_USERNAME = 'master1';
const MQTT_PASSWORD = 'Qwerty1234!';  // ðŸ”¥ Ð¢Ð’Ð†Ð™ ÐŸÐÐ ÐžÐ›Ð¬

const MASTER_TIMEOUT = 15000;          // 15 sec
const TABLE_INACTIVE_TIMEOUT = 900000; // 15 min
const PROCESS_INTERVAL = 2000;         // 2 sec

// ================= GLOBALS =================
let rawDataByMaster = {};
let processedData = {};
let lastProcessTime = 0;

// ================= MQTT =================
const client = mqtt.connect(MQTT_HOST, {
  username: MQTT_USERNAME,
  password: MQTT_PASSWORD,
  clean: true,
  connectTimeout: 4000,
  reconnectPeriod: 1000,
});

client.on('connect', () => {
  console.log('âœ… MQTT Connected');
  updateStatus('connected', 'Connected');
  
  client.subscribe('tracker/raw/#');
  client.subscribe('tracker/state');
  
  console.log('ðŸ“¡ Subscribed to topics');
});

client.on('message', (topic, message) => {
  try {
    const data = JSON.parse(message.toString());
    
    if (topic.startsWith('tracker/raw/')) {
      const masterId = topic.split('/')[2];
      
      rawDataByMaster[masterId] = {
        room: data.room,
        master_id: data.master_id,
        timestamp: data.timestamp,
        tables: data.tables || [],
        receivedAt: Date.now()
      };
      
      console.log(`ðŸ“¨ Master ${masterId}: ${data.tables.length} tables`);
      
      if (Date.now() - lastProcessTime > PROCESS_INTERVAL) {
        processData();
      }
    }
    
    if (topic === 'tracker/state') {
      processedData = data;
      renderDashboard();
    }
    
  } catch (e) {
    console.error('âŒ Parse error:', e);
  }
});

client.on('disconnect', () => {
  console.log('âš ï¸ Disconnected');
  updateStatus('disconnected', 'Disconnected');
});

client.on('error', (error) => {
  console.error('âŒ Error:', error);
  updateStatus('disconnected', 'Error');
});

client.on('reconnect', () => {
  console.log('ðŸ”„ Reconnecting...');
  updateStatus('connecting', 'Reconnecting...');
});

// ================= FUNCTIONS =================
function updateStatus(state, text) {
  const el = document.getElementById('status');
  el.className = `status-badge ${state}`;
  el.textContent = text;
}

function processData() {
  const now = Date.now();
  lastProcessTime = now;
  
  console.log('ðŸ”„ Processing data...');
  
  // Remove timeout Masters
  for (let masterId in rawDataByMaster) {
    if (now - rawDataByMaster[masterId].receivedAt > MASTER_TIMEOUT) {
      console.log(`âš ï¸ Master ${masterId} timeout`);
      delete rawDataByMaster[masterId];
    }
  }
  
  let rooms = {};
  let tableSignals = {};
  
  // Create rooms from Masters
  for (let masterId in rawDataByMaster) {
    let data = rawDataByMaster[masterId];
    let room = data.room;
    
    if (!rooms[room]) {
      rooms[room] = {
        active: true,
        master_id: data.master_id,
        tables: {}
      };
    }
  }
  
  // Collect table signals
  for (let masterId in rawDataByMaster) {
    let data = rawDataByMaster[masterId];
    let room = data.room;
    
    (data.tables || []).forEach(table => {
      let id = table.id;
      
      if (!tableSignals[id]) tableSignals[id] = [];
      
      tableSignals[id].push({
        room: room,
        rssi: table.rssi,
        last_seen: table.last_seen || 0
      });
    });
  }
  
  // Determine room for each table
  for (let id in tableSignals) {
    let signals = tableSignals[id];
    let best = signals.reduce((a, b) => a.rssi > b.rssi ? a : b);
    
    let room = best.room;
    let inactive = best.last_seen > TABLE_INACTIVE_TIMEOUT;
    
    rooms[room].tables[id] = {
      rssi: best.rssi,
      inactive: inactive
    };
  }
  
  console.log(`âœ… Rooms: ${Object.keys(rooms).length}, Tables: ${Object.keys(tableSignals).length}`);
  
  processedData = {
    rooms: rooms,
    timestamp: now
  };
  
  renderDashboard();
  
  client.publish('tracker/state', JSON.stringify(processedData), {retain: true});
}

function renderDashboard() {
  if (!processedData.rooms || Object.keys(processedData.rooms).length === 0) {
    document.getElementById('rooms').innerHTML = `
      <div class="loading">
        <div class="spinner"></div>
        Waiting for data from Masters...
      </div>`;
    updateStats(0, 0, 0);
    return;
  }
  
  let html = '';
  let totalTables = 0;
  let activeTables = 0;
  
  let roomNames = Object.keys(processedData.rooms).sort();
  
  roomNames.forEach(roomName => {
    let room = processedData.rooms[roomName];
    let tables = room.tables || {};
    let tableIds = Object.keys(tables);
    let count = tableIds.length;
    let isActive = room.active !== false;
    
    totalTables += count;
    
    html += `
    <div class="room-card ${isActive ? '' : 'offline'}">
      <div class="room-header">
        <div class="room-title">${roomName}</div>
        <div class="room-status ${isActive ? '' : 'offline'}">
          ${isActive ? 'Online' : 'Offline'}
        </div>
      </div>
      <div class="room-body">`;
    
    if (count === 0) {
      html += `
        <div class="empty-state">
          <div class="empty-state-icon">ðŸ“­</div>
          <div class="empty-state-text">No tables detected</div>
        </div>`;
    } else {
      html += '<div class="tables-grid">';
      
      tableIds.sort((a, b) => parseInt(a) - parseInt(b));
      
      tableIds.forEach(tableId => {
        let table = tables[tableId];
        let inactive = table.inactive || false;
        let rssi = table.rssi || 0;
        
        if (!inactive) activeTables++;
        
        html += `
        <div class="table ${inactive ? 'inactive' : ''}" 
             title="Table ${tableId}: ${rssi} dBm">
          <div class="table-id">${tableId}</div>
          <div class="table-rssi">${rssi} dBm</div>
        </div>`;
      });
      
      html += '</div>';
    }
    
    html += '</div></div>';
  });
  
  document.getElementById('rooms').innerHTML = html;
  updateStats(roomNames.length, totalTables, activeTables);
}

function updateStats(rooms, tables, active) {
  document.getElementById('stat-rooms').textContent = rooms;
  document.getElementById('stat-tables').textContent = tables;
  document.getElementById('stat-active').textContent = active;
}

function updateConfig() {
  let espnowTime = parseInt(document.getElementById('espnow-time').value);
  let cycleInterval = parseInt(document.getElementById('cycle-interval').value);
  
  if (espnowTime < 1000 || espnowTime > 30000) {
    alert('ESP-NOW time: 1000-30000 ms');
    return;
  }
  
  if (cycleInterval < 2000 || cycleInterval > 60000) {
    alert('Cycle interval: 2000-60000 ms');
    return;
  }
  
  if (cycleInterval <= espnowTime) {
    alert('Cycle must be greater than ESP-NOW time');
    return;
  }
  
  console.log(`âš™ï¸ Updating config: espnow=${espnowTime}ms, cycle=${cycleInterval}ms`);
  
  for (let masterId in rawDataByMaster) {
    let config = {
      espnow_time: espnowTime,
      cycle_interval: cycleInterval
    };
    
    let topic = `tracker/config/${masterId}`;
    client.publish(topic, JSON.stringify(config));
    console.log(`ðŸ“¤ Sent to Master ${masterId}`);
  }
  
  alert('âœ… Configuration sent to all Masters!');
}

// Auto-process
setInterval(() => {
  if (Object.keys(rawDataByMaster).length > 0) {
    processData();
  }
}, PROCESS_INTERVAL);

// Initial render
renderDashboard();
</script>

</body>
</html>
