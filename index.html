<!DOCTYPE html>
<html lang="uk">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Table Tracker Dashboard</title>
<style>
* {
  box-sizing: border-box;
  margin: 0;
  padding: 0;
}

body {
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
  color: #fff;
  min-height: 100vh;
  overflow-x: hidden;
}

/* Header */
.header {
  background: rgba(0, 0, 0, 0.2);
  backdrop-filter: blur(10px);
  padding: 20px;
  display: flex;
  justify-content: space-between;
  align-items: center;
  flex-wrap: wrap;
  gap: 15px;
  box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
}

.header h1 {
  font-size: 28px;
  font-weight: 700;
  display: flex;
  align-items: center;
  gap: 10px;
}

.status-badge {
  padding: 8px 20px;
  border-radius: 20px;
  font-size: 14px;
  font-weight: 600;
  display: inline-flex;
  align-items: center;
  gap: 8px;
  transition: all 0.3s;
}

.status-badge::before {
  content: '';
  width: 8px;
  height: 8px;
  border-radius: 50%;
  animation: pulse 2s infinite;
}

.status-badge.connected {
  background: #22c55e;
  color: #000;
}

.status-badge.connected::before {
  background: #000;
}

.status-badge.disconnected {
  background: #ef4444;
  color: #fff;
}

.status-badge.disconnected::before {
  background: #fff;
}

.status-badge.connecting {
  background: #f59e0b;
  color: #000;
}

.status-badge.connecting::before {
  background: #000;
}

@keyframes pulse {
  0%, 100% { opacity: 1; }
  50% { opacity: 0.5; }
}

/* Stats */
.stats {
  background: rgba(0, 0, 0, 0.2);
  backdrop-filter: blur(10px);
  padding: 15px 20px;
  display: flex;
  justify-content: center;
  gap: 40px;
  flex-wrap: wrap;
}

.stat {
  text-align: center;
}

.stat-value {
  font-size: 32px;
  font-weight: 700;
  line-height: 1;
}

.stat-label {
  font-size: 12px;
  opacity: 0.8;
  margin-top: 5px;
  text-transform: uppercase;
  letter-spacing: 1px;
}

/* Legend */
.legend {
  background: rgba(0, 0, 0, 0.2);
  backdrop-filter: blur(10px);
  padding: 12px 20px;
  text-align: center;
  font-size: 13px;
  display: flex;
  justify-content: center;
  gap: 20px;
  flex-wrap: wrap;
}

.legend-item {
  display: inline-flex;
  align-items: center;
  gap: 8px;
  padding: 4px 12px;
  background: rgba(255, 255, 255, 0.1);
  border-radius: 15px;
}

.legend-dot {
  width: 12px;
  height: 12px;
  border-radius: 50%;
}

.legend-dot.active { background: #22c55e; }
.legend-dot.warning { background: #f59e0b; }
.legend-dot.inactive { background: #ef4444; }
.legend-dot.stale { background: #6b7280; }

/* Rooms */
.rooms-container {
  padding: 20px;
  display: flex;
  flex-direction: column;
  gap: 20px;
}

.room-card {
  background: rgba(255, 255, 255, 0.95);
  border-radius: 20px;
  overflow: hidden;
  box-shadow: 0 10px 40px rgba(0, 0, 0, 0.2);
  transition: all 0.3s;
}

.room-card:hover {
  transform: translateY(-5px);
  box-shadow: 0 15px 50px rgba(0, 0, 0, 0.3);
}

.room-card.offline {
  opacity: 0.6;
  background: rgba(239, 68, 68, 0.1);
}

.room-header {
  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
  padding: 20px;
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.room-title {
  color: #fff;
  font-size: 24px;
  font-weight: 700;
}

.room-status {
  background: rgba(255, 255, 255, 0.2);
  color: #fff;
  padding: 6px 16px;
  border-radius: 20px;
  font-size: 13px;
  font-weight: 600;
  display: flex;
  align-items: center;
  gap: 6px;
}

.room-status::before {
  content: '';
  width: 6px;
  height: 6px;
  border-radius: 50%;
  background: #fff;
}

.room-status.offline {
  background: rgba(239, 68, 68, 0.3);
}

.room-status.offline::before {
  background: #ef4444;
}

.room-body {
  padding: 30px;
  min-height: 200px;
}

.tables-grid {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
  gap: 20px;
  justify-items: center;
}

.table {
  width: 100px;
  height: 100px;
  border-radius: 50%;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  color: #fff;
  font-weight: 700;
  transition: all 0.3s;
  cursor: pointer;
  position: relative;
}

.table:hover {
  transform: scale(1.1);
}

.table.active {
  background: linear-gradient(135deg, #22c55e 0%, #16a34a 100%);
  box-shadow: 0 4px 15px rgba(34, 197, 94, 0.3);
}

.table.active:hover {
  box-shadow: 0 8px 25px rgba(34, 197, 94, 0.5);
}

.table.warning {
  background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%);
  box-shadow: 0 4px 15px rgba(245, 158, 11, 0.3);
  animation: pulse-warning 2s infinite;
}

.table.warning:hover {
  box-shadow: 0 8px 25px rgba(245, 158, 11, 0.5);
}

.table.inactive {
  background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);
  box-shadow: 0 4px 15px rgba(239, 68, 68, 0.3);
  animation: pulse-danger 3s infinite;
}

.table.inactive:hover {
  box-shadow: 0 8px 25px rgba(239, 68, 68, 0.5);
}

.table.stale {
  background: linear-gradient(135deg, #6b7280 0%, #4b5563 100%);
  box-shadow: 0 4px 15px rgba(107, 114, 128, 0.3);
  opacity: 0.7;
}

.table.stale:hover {
  box-shadow: 0 8px 25px rgba(107, 114, 128, 0.5);
}

@keyframes pulse-warning {
  0%, 100% { opacity: 1; }
  50% { opacity: 0.7; }
}

@keyframes pulse-danger {
  0%, 100% { opacity: 1; }
  50% { opacity: 0.6; }
}

.table-id {
  font-size: 28px;
  font-weight: 700;
}

.table-rssi {
  font-size: 11px;
  opacity: 0.9;
  margin-top: 4px;
}

.table-time {
  font-size: 9px;
  opacity: 0.8;
  margin-top: 2px;
}

.empty-state {
  text-align: center;
  padding: 60px 20px;
  color: #94a3b8;
}

.empty-state-icon {
  font-size: 64px;
  opacity: 0.3;
  margin-bottom: 15px;
}

.empty-state-text {
  font-size: 18px;
  font-weight: 500;
}

.loading {
  text-align: center;
  padding: 100px 20px;
  color: #fff;
  font-size: 20px;
}

.spinner {
  border: 4px solid rgba(255, 255, 255, 0.3);
  border-top: 4px solid #fff;
  border-radius: 50%;
  width: 50px;
  height: 50px;
  animation: spin 1s linear infinite;
  margin: 0 auto 20px;
}

@keyframes spin {
  0% { transform: rotate(0deg); }
  100% { transform: rotate(360deg); }
}

.server-info {
  position: fixed;
  bottom: 10px;
  right: 10px;
  background: rgba(0, 0, 0, 0.5);
  backdrop-filter: blur(10px);
  padding: 10px 15px;
  border-radius: 10px;
  font-size: 11px;
  opacity: 0.7;
}

@media (max-width: 768px) {
  .header h1 { font-size: 20px; }
  .stats { gap: 20px; }
  .stat-value { font-size: 24px; }
  .legend { gap: 10px; }
  .tables-grid {
    grid-template-columns: repeat(auto-fill, minmax(80px, 1fr));
    gap: 15px;
  }
  .table {
    width: 80px;
    height: 80px;
  }
  .table-id { font-size: 22px; }
}
</style>
</head>
<body>

<div class="header">
  <h1>üéØ Table Tracker</h1>
  <div class="status-badge connecting" id="status">Connecting...</div>
</div>

<div class="stats" id="stats">
  <div class="stat">
    <div class="stat-value" id="stat-rooms">0</div>
    <div class="stat-label">Rooms</div>
  </div>
  <div class="stat">
    <div class="stat-value" id="stat-tables">0</div>
    <div class="stat-label">Total</div>
  </div>
  <div class="stat">
    <div class="stat-value" style="color: #22c55e" id="stat-active">0</div>
    <div class="stat-label">Active</div>
  </div>
  <div class="stat">
    <div class="stat-value" id="stat-masters">0</div>
    <div class="stat-label">Masters</div>
  </div>
</div>

<div class="legend">
  <div class="legend-item">
    <div class="legend-dot active"></div>
    <span>Active (&lt;30s)</span>
  </div>
  <div class="legend-item">
    <div class="legend-dot warning"></div>
    <span>Warning (30s-15m)</span>
  </div>
  <div class="legend-item">
    <div class="legend-dot inactive"></div>
    <span>Inactive (15m-30m)</span>
  </div>
  <div class="legend-item">
    <div class="legend-dot stale"></div>
    <span>Stale (&gt;30m)</span>
  </div>
</div>

<div class="rooms-container" id="rooms">
  <div class="loading">
    <div class="spinner"></div>
    Waiting for Masters...
  </div>
</div>

<div class="server-info" id="server-info">
  Broker: broker.emqx.io (public)
</div>

<script src="https://unpkg.com/mqtt@5.3.4/dist/mqtt.min.js"></script>
<script>
// ================= CONFIG =================
const MQTT_HOST = 'ws://broker.emqx.io:8083/mqtt';  // ‚Üê –ü—É–±–ª—ñ—á–Ω–∏–π –±—Ä–æ–∫–µ—Ä WebSocket

const MASTER_TIMEOUT = 15000;
const TABLE_WARNING_TIMEOUT = 30000;
const TABLE_INACTIVE_TIMEOUT = 900000;
const TABLE_STALE_TIMEOUT = 1800000;
const CLEANUP_INTERVAL = 3600000;

// ================= DATA STRUCTURES =================
let masters = {};
let tables = {};

// ================= MQTT =================
const client = mqtt.connect(MQTT_HOST, {
  // –ë–µ–∑ username/password (–ø—É–±–ª—ñ—á–Ω–∏–π –±—Ä–æ–∫–µ—Ä)
  clean: true,
  connectTimeout: 4000,
  reconnectPeriod: 1000,
});

client.on('connect', () => {
  console.log('‚úÖ MQTT Connected to public broker');
  updateStatus('connected', 'Connected');
  
  client.subscribe('tracker/raw/#', (err) => {
    if (!err) {
      console.log('üì° Subscribed to tracker/raw/#');
    }
  });
});

client.on('message', (topic, message) => {
  try {
    if (topic.startsWith('tracker/raw/')) {
      const masterId = topic.split('/')[2];
      const data = JSON.parse(message.toString());
      handleMasterData(masterId, data);
    }
  } catch (e) {
    console.error('‚ùå Parse error:', e);
  }
});

client.on('disconnect', () => {
  console.log('‚ö†Ô∏è Disconnected');
  updateStatus('disconnected', 'Disconnected');
});

client.on('error', (error) => {
  console.error('‚ùå Error:', error);
  updateStatus('disconnected', 'Error');
});

client.on('reconnect', () => {
  console.log('üîÑ Reconnecting...');
  updateStatus('connecting', 'Reconnecting...');
});

// ================= MASTER DATA HANDLER =================
function handleMasterData(masterId, data) {
  const now = Date.now();
  
  masters[masterId] = {
    room: data.room,
    master_id: data.master_id,
    lastSeen: now,
    active: true
  };
  
  console.log(`üì® Master ${masterId} (${data.room}): ${data.tables.length} tables`);
  
  (data.tables || []).forEach(table => {
    const tableId = table.id;
    const rssi = table.rssi;
    const lastSeen = table.last_seen || 0;
    
    if (!tables[tableId]) {
      tables[tableId] = { signals: [] };
      console.log(`  [TABLE+] TX_${tableId} added`);
    }
    
    const existingSignalIndex = tables[tableId].signals.findIndex(
      s => s.master_id === data.master_id
    );
    
    const signal = {
      room: data.room,
      master_id: data.master_id,
      rssi: rssi,
      timestamp: now - lastSeen
    };
    
    if (existingSignalIndex >= 0) {
      tables[tableId].signals[existingSignalIndex] = signal;
    } else {
      tables[tableId].signals.push(signal);
    }
  });
  
  processAndRender();
}

// ================= PROCESS STATE =================
function processAndRender() {
  const now = Date.now();
  
  for (let masterId in masters) {
    if (now - masters[masterId].lastSeen > MASTER_TIMEOUT) {
      if (masters[masterId].active) {
        console.log(`‚ö†Ô∏è  Master ${masterId} timeout`);
        masters[masterId].active = false;
      }
    }
  }
  
  for (let tableId in tables) {
    tables[tableId].signals = tables[tableId].signals.filter(signal => {
      return (now - signal.timestamp) < CLEANUP_INTERVAL;
    });
    
    if (tables[tableId].signals.length === 0) {
      console.log(`  [TABLE-] TX_${tableId} removed`);
      delete tables[tableId];
    }
  }
  
  let rooms = {};
  
  for (let masterId in masters) {
    if (!masters[masterId].active) continue;
    
    const room = masters[masterId].room;
    if (!rooms[room]) {
      rooms[room] = {
        active: true,
        master_id: masters[masterId].master_id,
        tables: {}
      };
    }
  }
  
  let activeCount = 0;
  
  for (let tableId in tables) {
    const signals = tables[tableId].signals;
    if (signals.length === 0) continue;
    
    const bestSignal = signals.reduce((best, current) => {
      return current.rssi > best.rssi ? current : best;
    });
    
    const room = bestSignal.room;
    const lastSeen = now - bestSignal.timestamp;
    
    let status = 'active';
    if (lastSeen > TABLE_STALE_TIMEOUT) {
      status = 'stale';
    } else if (lastSeen > TABLE_INACTIVE_TIMEOUT) {
      status = 'inactive';
    } else if (lastSeen > TABLE_WARNING_TIMEOUT) {
      status = 'warning';
    } else {
      activeCount++;
    }
    
    if (rooms[room]) {
      rooms[room].tables[tableId] = {
        rssi: bestSignal.rssi,
        last_seen: lastSeen,
        status: status
      };
    }
  }
  
  const roomCount = Object.keys(rooms).length;
  const tableCount = Object.keys(tables).length;
  const masterCount = Object.keys(masters).filter(id => masters[id].active).length;
  
  console.log(`üìä State: ${roomCount} rooms, ${tableCount} tables (‚úì${activeCount})`);
  
  renderDashboard(rooms, roomCount, tableCount, activeCount, masterCount);
  updateServerInfo();
}

// ================= RENDER =================
function renderDashboard(rooms, roomCount, tableCount, activeCount, masterCount) {
  if (!rooms || Object.keys(rooms).length === 0) {
    document.getElementById('rooms').innerHTML = `
      <div class="loading">
        <div class="spinner"></div>
        Waiting for Masters...
      </div>`;
    updateStats(0, 0, 0, 0);
    return;
  }
  
  let html = '';
  let roomNames = Object.keys(rooms).sort();
  
  roomNames.forEach(roomName => {
    let room = rooms[roomName];
    let tables = room.tables || {};
    let tableIds = Object.keys(tables);
    let count = tableIds.length;
    let isActive = room.active !== false;
    
    html += `
    <div class="room-card ${isActive ? '' : 'offline'}">
      <div class="room-header">
        <div class="room-title">${roomName}</div>
        <div class="room-status ${isActive ? '' : 'offline'}">
          ${isActive ? 'Online' : 'Offline'}
        </div>
      </div>
      <div class="room-body">`;
    
    if (count === 0) {
      html += `
        <div class="empty-state">
          <div class="empty-state-icon">üì≠</div>
          <div class="empty-state-text">No tables detected</div>
        </div>`;
    } else {
      html += '<div class="tables-grid">';
      
      tableIds.sort((a, b) => parseInt(a) - parseInt(b));
      
      tableIds.forEach(tableId => {
        let table = tables[tableId];
        let status = table.status || 'active';
        let rssi = table.rssi || 0;
        let lastSeen = table.last_seen || 0;
        let lastSeenText = formatTime(lastSeen);
        
        let statusEmoji = {
          'active': '‚úì',
          'warning': '‚ö†',
          'inactive': '‚úó',
          'stale': '‚è∏'
        }[status] || '?';
        
        html += `
        <div class="table ${status}" 
             title="Table ${tableId}
Status: ${status}
RSSI: ${rssi} dBm
Last seen: ${lastSeenText} ago">
          <div class="table-id">${tableId}</div>
          <div class="table-rssi">${rssi} dBm</div>
          <div class="table-time">${statusEmoji} ${lastSeenText}</div>
        </div>`;
      });
      
      html += '</div>';
    }
    
    html += '</div></div>';
  });
  
  document.getElementById('rooms').innerHTML = html;
  updateStats(roomCount, tableCount, activeCount, masterCount);
}

// ================= HELPERS =================
function updateStatus(state, text) {
  const el = document.getElementById('status');
  el.className = `status-badge ${state}`;
  el.textContent = text;
}

function updateServerInfo() {
  const masterCount = Object.keys(masters).filter(id => masters[id].active).length;
  document.getElementById('server-info').textContent = 
    `Broker: broker.emqx.io | ${masterCount} Master${masterCount !== 1 ? 's' : ''}`;
}

function formatTime(ms) {
  if (ms < 1000) return 'now';
  if (ms < 60000) return `${Math.floor(ms/1000)}s`;
  if (ms < 3600000) return `${Math.floor(ms/60000)}m`;
  return `${Math.floor(ms/3600000)}h`;
}

function updateStats(rooms, tables, active, masters) {
  document.getElementById('stat-rooms').textContent = rooms;
  document.getElementById('stat-tables').textContent = tables;
  document.getElementById('stat-active').textContent = active;
  document.getElementById('stat-masters').textContent = masters;
}

setInterval(() => {
  const now = Date.now();
  for (let tableId in tables) {
    tables[tableId].signals = tables[tableId].signals.filter(signal => {
      return (now - signal.timestamp) < CLEANUP_INTERVAL;
    });
    if (tables[tableId].signals.length === 0) {
      delete tables[tableId];
    }
  }
  processAndRender();
}, 60000);

renderDashboard({}, 0, 0, 0, 0);
</script>

</body>
</html>
