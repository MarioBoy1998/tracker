<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>Table Tracker</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<style>
* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

body {
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
  background: #0a0a0a;
  color: #e0e0e0;
  min-height: 100vh;
}

/* Header */
.header {
  background: #111;
  border-bottom: 1px solid #222;
  padding: 20px;
  display: flex;
  justify-content: space-between;
  align-items: center;
  flex-wrap: wrap;
  gap: 15px;
}

.header h1 {
  font-size: 24px;
  font-weight: 600;
  color: #fff;
}

.status-badge {
  padding: 6px 16px;
  border-radius: 20px;
  font-size: 13px;
  font-weight: 600;
  display: inline-flex;
  align-items: center;
  gap: 6px;
}

.status-badge.connected {
  background: #15803d;
  color: #fff;
}

.status-badge.disconnected {
  background: #991b1b;
  color: #fff;
}

.status-badge.connecting {
  background: #b45309;
  color: #fff;
}

/* Stats */
.stats {
  background: #111;
  border-bottom: 1px solid #222;
  padding: 15px 20px;
  display: flex;
  justify-content: center;
  gap: 40px;
  flex-wrap: wrap;
}

.stat {
  text-align: center;
}

.stat-value {
  font-size: 28px;
  font-weight: 700;
  color: #fff;
}

.stat-label {
  font-size: 11px;
  color: #888;
  margin-top: 4px;
  text-transform: uppercase;
  letter-spacing: 1px;
}

/* Rooms Container */
.rooms-container {
  padding: 20px;
  display: flex;
  flex-direction: column;
  gap: 20px;
}

/* Room Card */
.room-card {
  background: #111;
  border: 1px solid #222;
  border-radius: 12px;
  overflow: hidden;
}

.room-card.offline {
  opacity: 0.5;
}

.room-header {
  background: #1a1a1a;
  padding: 15px 20px;
  border-bottom: 1px solid #222;
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.room-title {
  font-size: 18px;
  font-weight: 600;
  color: #fff;
}

.room-status {
  padding: 4px 12px;
  border-radius: 12px;
  font-size: 12px;
  font-weight: 600;
}

.room-status.online {
  background: #15803d;
  color: #fff;
}

.room-status.offline {
  background: #991b1b;
  color: #fff;
}

.room-body {
  padding: 20px;
}

/* Tables Grid */
.tables-grid {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
  gap: 12px;
}

/* Table Item */
.table-item {
  background: #0a0a0a;
  border: 2px solid #222;
  border-radius: 12px;
  padding: 12px;
  text-align: center;
  transition: all 0.2s;
  position: relative;
}

.table-item:hover {
  border-color: #333;
  transform: translateY(-2px);
}

.table-item.active {
  border-color: #15803d;
  background: #0f1f13;
}

.table-item.warning {
  border-color: #b45309;
  background: #1a1107;
}

.table-item.inactive {
  border-color: #991b1b;
  background: #1a0808;
}

.table-item.stale {
  border-color: #444;
  background: #0f0f0f;
  opacity: 0.6;
}

.table-confidence {
  position: absolute;
  top: 6px;
  right: 8px;
  font-size: 10px;
  font-weight: 600;
  color: #888;
  background: #1a1a1a;
  padding: 2px 6px;
  border-radius: 8px;
}

.table-id {
  font-size: 20px;
  font-weight: 700;
  color: #fff;
  margin-bottom: 4px;
}

.table-rssi {
  font-size: 13px;
  color: #888;
  margin-bottom: 4px;
}

.table-status {
  font-size: 11px;
  color: #666;
  text-transform: uppercase;
  letter-spacing: 0.5px;
  margin-bottom: 2px;
}

.table-time {
  font-size: 10px;
  color: #555;
}

/* Empty State */
.empty-state {
  text-align: center;
  padding: 40px;
  color: #555;
}

.empty-state-icon {
  font-size: 48px;
  margin-bottom: 10px;
  opacity: 0.3;
}

.empty-state-text {
  font-size: 14px;
}

/* Loading */
.loading {
  text-align: center;
  padding: 60px 20px;
  color: #666;
}

.spinner {
  border: 3px solid #222;
  border-top: 3px solid #666;
  border-radius: 50%;
  width: 40px;
  height: 40px;
  animation: spin 1s linear infinite;
  margin: 0 auto 15px;
}

@keyframes spin {
  0% { transform: rotate(0deg); }
  100% { transform: rotate(360deg); }
}

/* Responsive */
@media (max-width: 768px) {
  .header h1 {
    font-size: 20px;
  }
  
  .stats {
    gap: 20px;
  }
  
  .stat-value {
    font-size: 24px;
  }
  
  .tables-grid {
    grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
    gap: 10px;
  }
}
</style>
</head>
<body>

<div class="header">
  <h1>üéØ Table Tracker</h1>
  <div class="status-badge connecting" id="status">Connecting...</div>
</div>

<div class="stats">
  <div class="stat">
    <div class="stat-value" id="stat-rooms">0</div>
    <div class="stat-label">Rooms</div>
  </div>
  <div class="stat">
    <div class="stat-value" id="stat-tables">0</div>
    <div class="stat-label">Tables</div>
  </div>
  <div class="stat">
    <div class="stat-value" id="stat-active">0</div>
    <div class="stat-label">Active</div>
  </div>
  <div class="stat">
    <div class="stat-value" id="stat-masters">0</div>
    <div class="stat-label">Masters</div>
  </div>
</div>

<div class="rooms-container" id="rooms">
  <div class="loading">
    <div class="spinner"></div>
    <div>Waiting for data...</div>
  </div>
</div>

<script src="https://unpkg.com/mqtt@5.3.4/dist/mqtt.min.js"></script>
<script>
// ================= CONFIG =================
const MQTT_HOST = 'wss://f3fbfed182654a99bd2d329ffb0aef99.s1.eu.hivemq.cloud:8884/mqtt';
const MQTT_USERNAME = 'master1';
const MQTT_PASSWORD = 'Qwerty1234!';

const MASTER_TIMEOUT = 15000;
const TABLE_WARNING_TIMEOUT = 30000;
const TABLE_INACTIVE_TIMEOUT = 900000;
const TABLE_STALE_TIMEOUT = 1800000;
const CLEANUP_INTERVAL = 3600000;

const SIGNAL_FRESHNESS_THRESHOLD = 30000;
const RSSI_DIFFERENCE_THRESHOLD = 10;
const MIN_RSSI_FOR_ROOM = -90;
const CONFIDENCE_THRESHOLD = 0.8;
const HISTORY_LENGTH = 2;

// ================= DATA =================
let masters = {};
let tables = {};
let tableHistory = {};

// ================= MQTT =================
const client = mqtt.connect(MQTT_HOST, {
  username: MQTT_USERNAME,
  password: MQTT_PASSWORD,
  clean: true,
  connectTimeout: 4000,
  reconnectPeriod: 1000,
});

client.on('connect', () => {
  console.log('‚úÖ Connected');
  updateStatus('connected', 'Connected');
  
  client.subscribe('tracker/raw/#', (err) => {
    if (!err) console.log('üì° Subscribed');
  });
});

client.on('message', (topic, message) => {
  try {
    if (topic.startsWith('tracker/raw/')) {
      const masterId = topic.split('/')[2];
      const data = JSON.parse(message.toString());
      handleMasterData(masterId, data);
    }
  } catch (e) {
    console.error('Parse error:', e);
  }
});

client.on('disconnect', () => {
  updateStatus('disconnected', 'Disconnected');
});

client.on('error', (error) => {
  updateStatus('disconnected', 'Error');
});

client.on('reconnect', () => {
  updateStatus('connecting', 'Reconnecting...');
});

// ================= HISTORY =================
function updateTableHistory(tableId, roomName, rssi, timestamp) {
  if (!tableHistory[tableId]) {
    tableHistory[tableId] = [];
  }

  tableHistory[tableId].push({
    room: roomName,
    rssi: rssi,
    timestamp: timestamp
  });

  if (tableHistory[tableId].length > HISTORY_LENGTH) {
    tableHistory[tableId].shift();
  }
}

function calculateConfidence(tableId, roomName) {
  if (!tableHistory[tableId] || tableHistory[tableId].length === 0) {
    return 0.5;
  }

  const recentHistory = tableHistory[tableId].slice(-HISTORY_LENGTH);
  const roomCount = recentHistory.filter(h => h.room === roomName).length;

  return roomCount / recentHistory.length;
}

// ================= HANDLERS =================
function handleMasterData(masterId, data) {
  const now = Date.now();
  
  masters[masterId] = {
    room: data.room,
    master_id: data.master_id,
    lastSeen: now,
    active: true
  };
  
  console.log(`üì® Master ${masterId} (${data.room}): ${data.tables.length} tables`);
  
  (data.tables || []).forEach(table => {
    const tableId = table.id;
    const rssi = table.rssi;
    const lastSeen = table.last_seen || 0;
    
    if (!tables[tableId]) {
      tables[tableId] = { signals: [] };
      console.log(`  [+] TX_${tableId}`);
    }
    
    const existingIndex = tables[tableId].signals.findIndex(
      s => s.master_id === data.master_id
    );
    
    const signal = {
      room: data.room,
      master_id: data.master_id,
      rssi: rssi,
      timestamp: now - lastSeen
    };
    
    if (existingIndex >= 0) {
      tables[tableId].signals[existingIndex] = signal;
    } else {
      tables[tableId].signals.push(signal);
    }
    
    updateTableHistory(tableId, data.room, rssi, now);
  });
  
  processAndRender();
}

// ================= PROCESS =================
function processAndRender() {
  const now = Date.now();
  
  // Timeout Masters
  for (let masterId in masters) {
    if (now - masters[masterId].lastSeen > MASTER_TIMEOUT) {
      if (masters[masterId].active) {
        console.log(`‚ö†Ô∏è Master ${masterId} timeout`);
        masters[masterId].active = false;
      }
    }
  }
  
  // Cleanup old signals
  for (let tableId in tables) {
    tables[tableId].signals = tables[tableId].signals.filter(signal => {
      return (now - signal.timestamp) < CLEANUP_INTERVAL;
    });
    
    if (tables[tableId].signals.length === 0) {
      console.log(`  [-] TX_${tableId}`);
      delete tables[tableId];
      delete tableHistory[tableId];
    }
  }
  
  // Build rooms
  let rooms = {};
  
  for (let masterId in masters) {
    if (!masters[masterId].active) continue;
    
    const room = masters[masterId].room;
    if (!rooms[room]) {
      rooms[room] = {
        active: true,
        master_id: masters[masterId].master_id,
        tables: []
      };
    }
  }
  
  // Process tables
  let activeCount = 0;
  let warningCount = 0;
  let inactiveCount = 0;
  let staleCount = 0;
  
  for (let tableId in tables) {
    const signals = tables[tableId].signals;
    if (signals.length === 0) continue;
    
    const lastSignal = signals.reduce((newest, current) => {
      return current.timestamp > newest.timestamp ? current : newest;
    });
    const currentRoom = lastSignal.room;
    
    const signalsByRoom = {};
    signals.forEach(signal => {
      if (!signalsByRoom[signal.room]) signalsByRoom[signal.room] = [];
      signalsByRoom[signal.room].push(signal);
    });
    
    const freshestByRoom = {};
    for (let room in signalsByRoom) {
      freshestByRoom[room] = signalsByRoom[room].reduce((newest, current) => {
        return current.timestamp > newest.timestamp ? current : newest;
      });
    }
    
    const currentRoomSignal = freshestByRoom[currentRoom];
    const currentRoomAge = currentRoomSignal ? (now - currentRoomSignal.timestamp) : Infinity;
    const currentRoomFresh = currentRoomAge < SIGNAL_FRESHNESS_THRESHOLD;
    
    let finalRoom = currentRoom;
    let finalSignal = currentRoomSignal || lastSignal;
    
    if (currentRoomFresh && currentRoomSignal.rssi >= MIN_RSSI_FOR_ROOM) {
      let bestRoom = currentRoom;
      let bestSignal = currentRoomSignal;
      
      for (let room in freshestByRoom) {
        if (room === currentRoom) continue;
        
        const signal = freshestByRoom[room];
        const age = now - signal.timestamp;
        const isFresh = age < SIGNAL_FRESHNESS_THRESHOLD;
        
        if (isFresh && signal.rssi >= MIN_RSSI_FOR_ROOM) {
          if (signal.rssi - bestSignal.rssi > RSSI_DIFFERENCE_THRESHOLD) {
            bestRoom = room;
            bestSignal = signal;
          }
        }
      }
      
      finalRoom = bestRoom;
      finalSignal = bestSignal;
      
    } else if (currentRoomFresh && currentRoomSignal.rssi < MIN_RSSI_FOR_ROOM) {
      let bestRoom = null;
      let bestSignal = null;
      
      for (let room in freshestByRoom) {
        const signal = freshestByRoom[room];
        const age = now - signal.timestamp;
        const isFresh = age < SIGNAL_FRESHNESS_THRESHOLD;
        
        if (isFresh && signal.rssi >= MIN_RSSI_FOR_ROOM) {
          if (!bestSignal || signal.rssi > bestSignal.rssi) {
            bestRoom = room;
            bestSignal = signal;
          }
        }
      }
      
      if (bestSignal) {
        finalRoom = bestRoom;
        finalSignal = bestSignal;
      }
      
    } else {
      let emergencyRoom = null;
      let emergencySignal = null;
      
      for (let room in freshestByRoom) {
        const signal = freshestByRoom[room];
        const age = now - signal.timestamp;
        
        if (age < 10000 && signal.rssi >= MIN_RSSI_FOR_ROOM) {
          if (signal.rssi - finalSignal.rssi > RSSI_DIFFERENCE_THRESHOLD * 2) {
            emergencyRoom = room;
            emergencySignal = signal;
            break;
          }
        }
      }
      
      if (emergencySignal) {
        finalRoom = emergencyRoom;
        finalSignal = emergencySignal;
      }
    }
    
    const lastSeen = now - finalSignal.timestamp;
    const confidence = calculateConfidence(tableId, finalRoom);
    
    let status = 'active';
    if (lastSeen > TABLE_STALE_TIMEOUT) {
      status = 'stale';
      staleCount++;
    } else if (lastSeen > TABLE_INACTIVE_TIMEOUT) {
      status = 'inactive';
      inactiveCount++;
    } else if (lastSeen > TABLE_WARNING_TIMEOUT) {
      status = 'warning';
      warningCount++;
    } else {
      activeCount++;
    }
    
    if (rooms[finalRoom]) {
      rooms[finalRoom].tables.push({
        id: tableId,
        rssi: finalSignal.rssi,
        last_seen: lastSeen,
        status: status,
        confidence: confidence
      });
    }
  }
  
  const roomCount = Object.keys(rooms).length;
  const tableCount = Object.keys(tables).length;
  const masterCount = Object.keys(masters).filter(id => masters[id].active).length;
  
  console.log(`üìä ${roomCount} rooms, ${tableCount} tables (‚úì${activeCount} ‚ö†${warningCount} ‚úó${inactiveCount} ‚è∏${staleCount})`);
  
  render(rooms, roomCount, tableCount, activeCount, masterCount);
}

// ================= RENDER =================
function render(rooms, roomCount, tableCount, activeCount, masterCount) {
  if (!rooms || Object.keys(rooms).length === 0) {
    document.getElementById('rooms').innerHTML = `
      <div class="loading">
        <div class="spinner"></div>
        <div>Waiting for data...</div>
      </div>`;
    updateStats(0, 0, 0, 0);
    return;
  }
  
  let html = '';
  let roomNames = Object.keys(rooms).sort();
  
  roomNames.forEach(roomName => {
    let room = rooms[roomName];
    let tables = room.tables || [];
    let isActive = room.active !== false;
    
    tables.sort((a, b) => parseInt(a.id) - parseInt(b.id));
    
    html += `
    <div class="room-card ${isActive ? '' : 'offline'}">
      <div class="room-header">
        <div class="room-title">${roomName}</div>
        <div class="room-status ${isActive ? 'online' : 'offline'}">
          ${isActive ? 'Online' : 'Offline'}
        </div>
      </div>
      <div class="room-body">`;
    
    if (tables.length === 0) {
      html += `
        <div class="empty-state">
          <div class="empty-state-icon">üì≠</div>
          <div class="empty-state-text">No tables detected</div>
        </div>`;
    } else {
      html += '<div class="tables-grid">';
      
      tables.forEach(table => {
        let confidencePercent = Math.round(table.confidence * 100);
        let time = table.last_seen < 1000 ? 'now' : 
                   table.last_seen < 60000 ? `${Math.floor(table.last_seen/1000)}s` :
                   table.last_seen < 3600000 ? `${Math.floor(table.last_seen/60000)}m` :
                   `${Math.floor(table.last_seen/3600000)}h`;
        
        html += `
        <div class="table-item ${table.status}">
          <div class="table-confidence">${confidencePercent}%</div>
          <div class="table-id">${table.id}</div>
          <div class="table-rssi">${table.rssi} dBm</div>
          <div class="table-status">${table.status}</div>
          <div class="table-time">${time}</div>
        </div>`;
      });
      
      html += '</div>';
    }
    
    html += '</div></div>';
  });
  
  document.getElementById('rooms').innerHTML = html;
  updateStats(roomCount, tableCount, activeCount, masterCount);
}

// ================= HELPERS =================
function updateStatus(state, text) {
  const el = document.getElementById('status');
  el.className = `status-badge ${state}`;
  el.textContent = text;
}

function updateStats(rooms, tables, active, masters) {
  document.getElementById('stat-rooms').textContent = rooms;
  document.getElementById('stat-tables').textContent = tables;
  document.getElementById('stat-active').textContent = active;
  document.getElementById('stat-masters').textContent = masters;
}

// Auto cleanup
setInterval(() => {
  const now = Date.now();
  for (let tableId in tables) {
    tables[tableId].signals = tables[tableId].signals.filter(signal => {
      return (now - signal.timestamp) < CLEANUP_INTERVAL;
    });
    if (tables[tableId].signals.length === 0) {
      delete tables[tableId];
      delete tableHistory[tableId];
    }
  }
  processAndRender();
}, 60000);

// Init
render({}, 0, 0, 0, 0);
</script>
</body>
</html>
